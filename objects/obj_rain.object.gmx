<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-1000</depth>
  <persistent>0</persistent>
  <parentName>par_particules</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// create a particle system and turn off automatic drawing
// this will prevent our application surface from drawing our raindrops
global.ps = part_system_create();
part_system_automatic_draw(global.ps, false);

// we will draw particles on this surface
surf = surface_create(848, 240);

// create a raindrop particle
rain = part_type_create();
// optional angle, this will create some kind of wind effect
rain_angle = -15

// Raindrop
rain = part_type_create();
part_type_shape(rain , pt_shape_pixel);
part_type_size(rain, 2, 2, 0, 0);
part_type_scale(rain, 0.30, 8);
part_type_orientation(rain, rain_angle, rain_angle, 0, 0, 0);
part_type_color3(rain, 15133336, 15328923, 15702044);
part_type_alpha3(rain, 1, 1, 1);
part_type_blend(rain, 0);
part_type_life(rain, 100, 150);
part_type_speed(rain, 6, 16, 0, 0);
part_type_direction(rain, 270+rain_angle, 270+rain_angle, 0, 0);
part_system_depth(rain,-1000)
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// This just spawns 20 raindrops every step.
repeat(20) {
    part_particles_create(global.ps, random_range(-100, room_width+100), random_range(-100, 0), rain, 1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// surfaces are volatile so don't forget to create it again if it doesn't exist
if !surface_exists(surf) surf = surface_create(424, 240);

// set our surface as a target (for drawing on it)
surface_set_target(surf);

// fill the surface with transparent color to prevent particles from leaving ugly traces
draw_clear_alpha(1,0);

// tell the particle system to draw particles now (on our new surface)
part_system_drawit(global.ps);

// now we need to cut areas, so we use bm_subtract blend mode. whatever we draw will be cut off from the surface
draw_set_blend_mode(bm_subtract); // GMS 1.4

// now we iterate through each Solid object and we get its bounding box coordinates. see it as getting top-left, top-right, bottom-left and bottom-right corners.
with par_rainsolid {
    left = bbox_left;
    right = bbox_right;
    top = bbox_top;
    bottom = bbox_bottom;
    
    // set the left and right coordinates of our Solid object to xx1 and xx2. yy is just the room height, since we need to know how high our area will be.
    xx1 = left;
    xx2 = right;
    yy = room_height;
    
    // now onto drawing our primitives. first of all lets cut the area that our Solid object occupies. draw (and fill) a simple rectangle using the bounding box coordinates we've got before.
    draw_primitive_begin(pr_trianglestrip);
    draw_vertex(left, bottom);
    draw_vertex(right, bottom);
    draw_vertex(left, top);
    draw_vertex(right, top);
    draw_primitive_end();
    
    // and this draws (and fills) the area beneath our Solid object.
    draw_primitive_begin(pr_trianglestrip);
    angle = 90 + obj_rain.rain_angle;
    
    if obj_rain.rain_angle &lt;= 0 {
        ld1 = lengthdir_x(yy - top, angle);
        ld2 = lengthdir_x(yy - bottom, angle);
    } else {
        ld1 = lengthdir_x(yy - bottom, angle);
        ld2 = lengthdir_x(yy - top, angle);
    }
    draw_vertex(left-ld1, yy);
    draw_vertex(right-ld2, yy);
    draw_vertex(left, top);
    draw_vertex(right, bottom);

    draw_primitive_end();
       
}

// set the blend mode back to normal
draw_set_blend_mode(bm_normal); // GMS 1.4

// reset target and draw the surface
surface_reset_target();
draw_surface(surf, view_xview, view_yview);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
